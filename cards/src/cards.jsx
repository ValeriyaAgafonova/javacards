const hyberCards = [
  { q: "1. ORM. JPA. Hibernate.", a: `1. ORM: Object Relational Mapping - это концепция/процесс преобразования данных из объектно-ориентированного языка в реляционные БД и наоборот. Например, в Java это делается с помощью рефлексии и jdbc.
  2. Hibernate: реализация вышеуказанной концепции.
  3. JPA: Это на один шаг выше ORM. Его высокоуровневый API и спецификация,
  позволяющие реализовать различные инструменты ORM, что дает разработчику возможность гибко изменять реализацию с одной ORM на другую (например, если приложение использует API-интерфейс JPA и реализация находится в спящем режиме. В будущем он может переключиться на IBatis,
  если требуется. Но, с другой стороны, если приложение напрямую блокирует реализацию с помощью Hibernate без платформы JPA, переключение будет непростой задачей)
  https://stackoverflow.com/questions/27462185/jpa-vs-orm-vs-hibernate
  `,img: `` },
  { q: "2. JDBC vs. Hibernate.", a: `Hibernate является одним из самых востребованных ORM фреймворков для Java:
  1. Hibernate устраняет множество спагетти кода (повторяющегося), который постоянно преследует разработчика при работе с JDBC. Скрывает от разработчика множество
  кода, необходимого для управления ресурсами и позволяет сосредоточиться на
  бизнес логике.
  2. Hibernate поддерживает XML так же как и JPA аннотации, что позволяет сделать
  реализацию кода независимой.
  3. Hibernate предоставляет собственный мощный язык запросов (HQL), который похож
  на SQL. Стоит отметить, что HQL полностью объектно-ориентирован и понимает
  такие принципы, как наследование, полиморфизм и ассоциации (связи).
  4. Hibernate — широко распространенный open source проект. Благодаря этому
  доступны тысячи открытых статей, примеров, а также документации по
  использованию фреймворка.
  5. Hibernate легко интегрируется с другими Java EE фреймворками, например, Spring
  Framework поддерживает встроенную интеграцию с Hibernate.
  6. Hibernate поддерживает ленивую инициализацию используя proxy объекты и
  выполняет запросы к базе данных только по необходимости.
  7. Hibernate поддерживает разные уровни cache, а следовательно может повысить
  производительность.
  8. Важно, что Hibernate может использовать чистый SQL, а значит поддерживает
  возможность оптимизации запросов и работы с любым сторонним вендором БД и
  его фичами.
  9. Hibernate неявно использует управление транзакциями. Большинство запросов
  нельзя выполнить вне транзакций.
  10. Hibernate использует HibernateException (unchecked) значит нет необходимости
  проверять их в коде каждый раз.
  О proxy:
  Hibernate Proxy используется для замены реальной сущности POJO (Plain Old Java Object). Класс Proxy генерируется во время выполнения и расширяет исходный класс сущности. Hibernate использует объекты Proxy для объектов, чтобы разрешить отложенную загрузку. При доступе к основным свойствам прокси просто делегирует вызов исходной сущности. Каждый List, Set, Map тип в классе сущностей замещен PersistentList, PersistentSet, PersistentMap. Эти классы отвечают за перехват вызова неинициализированной коллекции. Прокси не выдает никаких операторов SQL. Он просто запускает InitializeCollectionEvent, который обрабатывается связанным прослушивателем, который знает, какой запрос инициализации выпустить (зависит от настроенного плана выборки).
  Proxy объект получаем через метод session.load(), если вызываем геттеры и сеттеры - выполняется select в базу на получение реального объекта. https://vladmihalcea.com/how-does-a-jpa-proxy-work-and-how-to-unproxy-it-with-hibernate/ https://habr.com/ru/post/271115/`, img: `` },
  { q: `3. Важные интерфейсы Hibernate (SessionFactory, Session,
    Transaction).`, a: `1. Session - обеспечивает физическое соединение между приложением и БД. Основная функция Session - предлагать операции создания, чтения и удаления для экземпляров классов сопоставленных сущностей.
    2. SessionFactory - это фабрика для объектов Session. Обычно создается во время запуска приложения и сохраняется для последующего использования. Является потокобезопасным объектом и используется всеми потоками приложения.
    3. Configuration - объект используется для конфигурирования и начальной загрузки Hibernate.
    4. Transaction - однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC транзакций. Session может занимать несколько Transaction в определенных случаях, является необязательным API.
    5. Query - интерфейс позволяет выполнять запросы к БД. Запросы написаны на HQL или на нативном диалекте SQL. Criteria позволяет создавать и выполнять объектно-ориентированные критерии запросов.
    https://www.tutorialspoint.com/jpa/jpa_architecture.htm https://www.java2novice.com/hibernate/session-interface-methods/ https://www.javaworld.com/article/2072999/get-started-with-hibernate.html?page=2`, img: `` },
    {q: `4. Требования к Entity в JPA.`, a: `1) Entity класс должен быть помечен аннотацией Entity или описан в XML файле конфигурации JPA,
    2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами),
    3) Entity класс должен быть классом верхнего уровня (top-level class), только у хибернейта 4) Entity класс не может быть enum или интерфейсом,
    5) Entity класс не может быть финальным классом (final class),
    6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables),
    7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс
    8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе),
    9) Entity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Entity класса в базе данных https://habr.com/ru/post/265061/
    Доп. инфа
    Entity класс может наследоваться от не Entity классов (non-entity classes) Entity класс может наследоваться от других Entity классов
    не Entity класс может наследоваться от Entity класса
        
    Entity может быть абстрактным классом (при этом он сохраняет все свойства Entity, за исключением того что его нельзя непосредственно инициализировать) https://habr.com/ru/post/265061/
    `, img: ``},
    {q: `5. EntityManager.`, a: `EntityManager это интерфейс, который описывает API для всех основных операций над Entity, получение данных и других сущностей JPA. По сути главный API для работы с JPA. Основные операции:
    1) Для операций над Entity: persist (добавление Entity под управление JPA), merge (обновление), remove (удаления), refresh (обновление данных), detach (удаление из управление JPA), lock (блокирование Entity от изменений в других thread),
    2) Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery 3) Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate
    4) Работа с EntityGraph: createEntityGraph, getEntityGraph
    5) Общие операции над EntityManager или всеми Entities: close, isOpen, getProperties, setProperty, clear. https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing
    `, img: ``},
    {q: `6. Виды связи (OneToOne, OneToMany, ManyToOne, ManyToMany).
    Unidirectional, bidirectional.`, a: `Существуют следующие четыре типа связей
    1. OneToOne (связь один к одному, то есть один объект Entity может связан не больше чем с один объектом другого Entity ),
    2. OneToMany (связь один ко многим, один объект Entity может быть связан с целой коллекцией других Entity),
    3. ManyToOne (связь многие к одному, обратная связь для OneToMany),
    4. ManyToMany (связь многие ко многим)
    Каждую из которых можно разделить еще на два вида:
    1. Bidirectional (пер. - Двунаправленный) — две связи
    2. Unidirectional (пер. - Однонаправленный ) — ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A, Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).Unidirectional - ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет. https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing
    `, img: ``},
    {q: `7. Владелец связи (mappedBy).`, a: `У mappedBy удалится колонка с внешним ключом, т.к. она будет на другой стороне и так. Этот атрибут говорит хибернейту что ключ для связи лежит на другой стороне. Это значит, что несмотря на то, что у нас есть две таблицы - только одна из них содержит ограничение на внешний ключ. Этот атрибут позволяет по-прежнему ссылаться из таблицы, которая не
     
    содержит ограничения на другую таблицу. Атрибут mappedBy тесно связан с аннотацией @JoinColumn. Если применить атрибут mappedBy на одной стороне связи - хибернейт не станет создавать смежную таблицу. https://docs.google.com/document/d/1QXEv9hnVRFHaPlPMF3CEIaxL8dQrWYx4MI5PLLj14Cc/ edit`, img: ``},
    {q: `8. Каскадирование.`, a: `Каскадирование - это когда мы выполняем какое-то действие с целевой сущностью, то же самое действие будет применено к связанной сущности.
    JPA CascadeType:
    ALL - распространяет все операции, включая специфичные для Hibernate, от родительского объекта к дочернему объекту.
    PERSIST - делает временный экземпляр постоянным. CascadeType.PERSIST передает операцию persist от родительского объекта к дочернему объекту . Когда мы сохраняем личность лица, адрес также будет сохранена.
    MERGE - операция слияния копирует состояние данного объекта в постоянный объект с тем же идентификатором. CascadeType.MERGE передает операцию слияния от родителя к дочерней сущности.
    REMOVE - удаляет строку, соответствующую объекту, из базы данных, а также из постоянного контекста.
    DETACH - удаляет объект из постоянного контекста. Когда мы используем CascadeType.DETACH, дочерняя сущность также будет удалена из постоянного контекста.
    Hibernate CascadeType:
    LOCK - повторно присоединяет сущность и связанную дочернюю сущность с постоянным контекстом снова.
    REFRESH - повторно считывают значение данного экземпляра из базы данных. В некоторых случаях мы можем изменить экземпляр после сохранения в базе данных, но позже нам нужно отменить эти изменения.
    REPLICATE - используется, когда у нас более одного источника данных, и мы хотим, чтобы данные были синхронизированы. С CascadeType.REPLICATE операция синхронизации также распространяется на дочерние объекты всякий раз, когда выполняется над родительским объектом.
    SAVE_UPDATE - распространяет ту же операцию на связанный дочерний объект. Это полезно, когда мы используем специфичные для Hibernate операции, такие как save, update и saveOrUpdate.
    https://www.baeldung.com/jpa-cascade-types
    `, img: ``},
    {q: `9. FetchType.`, a: `В JPA описаны два типа fetch стратегии:
    1) LAZY (пер. - ленивый)— данные поля будут загружены только во время первого доступа к этому полю,
    2) EAGER (пер. - жаждущий) — данные поля будут загружены немедленно.
    Используются по умолчанию:
    one(many)to many - lazy
    one(many)to one - eager https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing`, img: ``},

    {q: `10. orphanRemoval.`, a: `Директива orphanRemoval объявляет, что связанные экземпляры сущностей должны быть удалены, когда они отсоединены от родителя, или эквивалентно, когда родитель удален https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing
    `, img: ``},
    {q: `11. @Basic vs. @Column.`, a: `Различия:
    Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.
    @Basic имеет атрибут optional - может ли поле объекта быть нулевым или нет; с другой стороны у @Column атрибут nullable позволяет пометить столбец NOT NULL при создании схемы.
    Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво @Column аннотации позволяют указать имя отображаемого столбца базы данных https://www.baeldung.com/jpa-basic-annotation
    `, img: ``},
    {q: `12. Маппинг энамов и дат.`, a: `@Enumerated указывает, следует ли сохранять Enum по имени или по порядковому номеру (по умолчанию).
    https://www.baeldung.com/jpa-persisting-enums-in-jpa
    https://www.baeldung.com/jpa-entities
    @Enumerated(EnumType.STRING) - означает, что в базе будет хранятся имена Enam. @Enumerated(EnumType.ORDINAL) - означает, что в базе будет хранятся порядковые номера Enum.
    https://www.baeldung.com/jpa-persisting-enums-in-jpa
    Аннотация @Temporal до Java 8.
    @Temporal (пер. временный) – применяется к полям или свойствам с типом java.util.Date и java.util.Calendar.
    Уже не нужно ставить аннотацию в Java 8
    https://www.baeldung.com/hibernate-date-time
    `, img: ``},
    {q: `13. Жизненный цикл сущности (new, managed, detached, removed) и операции (persist, merge, detach, remove, refresh) над сущностью в разных состояниях жизненного цикла.`, a: `1) new - объект создан, не имеет primary key
    2) managed (пер. - удалось) - объект создан, имеет primary key, управляется
    JPA
    3) detached (пер. - отстраненный) - объект создан, не управляется JPA
    4) removed (пер. удаленный) - объект создан, управляется JPA, будет удален
    при commit-е
    https://habr.com/ru/post/271115/
    persist()
    - new → managed, и объект будет сохранен в базу при commit-е транзакции или в
    результате flush операций
    - managed → операция игнорируется, однако зависимые Entity могут поменять статус
    на managed, если у них есть аннотации каскадных изменений
    - removed → managed
    - detached → exception сразу или на этапе commit-а транзакции
    remove()
    - new → операция игнорируется, однако зависимые Entity могут поменять статус на
    removed, если у них есть аннотации каскадных изменений и они имели статус
    managed
    - managed → removed и запись объект в базе данных будет удалена при commit-е
    транзакции (также произойдут операции remove для всех каскадно зависимых
    объектов)
    - removed → операция игнорируется
    - detached → exception сразу или на этапе commit-а транзакции,
    merge()
    - detached → либо данные будут скопированы в существующий managed entity с тем
    же первичным ключом, либо создан новый managed в который скопируются данные
     
    - new → будет создана новый managed entity, в который будут скопированы данные прошлого объекта
    - managed → операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если их статус не managed
    - removed → exception сразу или на этапе commit-а транзакции, refresh()
    - managed → будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов
    - new, removed, detached → exception detach()
    - managed, removed → detached.
    - new, detached → операция игнорируется
    https://habr.com/ru/post/265061/`, img: `scheme.png`},

    {q: `14. Inheritance (3 стратегии построения иерархии) vs.
    @MappedSuperClass.`, a: `
    В JPA описаны три стратегии наследования маппинга (Inheritance Mapping Strategies), то есть как JPA будет работать с классами-наследниками Entity:
    1) одна таблица на всю иерархию наследования (a single table per class hierarchy) — все entity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”. Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog».Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соответственно.
    2) объединяющая стратегия (joined subclass strategy) — в этой стратегии каждый класс entity сохраняет данные в свою таблицу, но только уникальные колонки (не унаследованные от классов-предков) и первичный ключ, а все унаследованные колонки записываются в таблицы класса-предка, дополнительно устанавливается связь (relationships) между этими таблицами, например в случае классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. Минусом тут являются потери производительности от объединения таблиц (join) для любых операций.
    3) одна таблица для каждого класса (table per concrete class strategy) — тут все просто каждый отдельный класс-наследник имеет свою таблицу, т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса. MappedSuperclass это класс от которого наследуются Entity, он может содержать аннотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. Такой
     
    класс должен быть отмечен аннотацией @MappedSuperclass или соответственно описан в xml файле. https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing
    `, img: ``},
    {q: `15. n + 1 select (описание и решения).`, a: `Допустим, у вас есть коллекция Car объектов (строк базы данных), и у каждого Car есть коллекция Wheel объектов (также строк). Другими словами, Car→ Wheel это отношение 1-ко-многим.
    Теперь предположим, что вам нужно пройтись по всем машинам, и для каждой распечатать список колес:
    SELECT * FROM Cars;
    И тогда для каждого Car:
    SELECT * FROM Wheel WHERE CarId = ?
    Другими словами, у вас есть один выбор для автомобилей, а затем N дополнительных выборов, где N - общее количество автомобилей.
    В качестве альтернативы можно получить все колеса и выполнить поиск в памяти: SELECT * FROM Wheel
    Это уменьшает количество обращений к базе данных с N+1 до 2. Большинство инструментов ORM предоставляют несколько способов предотвратить выбор N+1. https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relation al-mapping 
    Решения: смотри схему
    * - если не используем аннотацию JoinColumn и оставляем связанную третью таблицу
** - работает только при выборке собственника с коллекцией зависимых сущностей
*** - работает только при выборке дочерней сущности с ссылкой на родительскую сущность Выводы:
1. Лучшим вариантом решения N+1 проблемы для простых запросов (1-3 уровня вложенности связанных объектов) будет join fetch и jpql запрос. Следует придерживаться тактики, когда мы выбираем из jpql и нативного запроса jpql
2. Если у нас имеется нативный запрос, и мы не заботимся о слабой связанности кода - то хорошим вариантом будет использование Hibernate Specific Mapping. В противном случае стоит использовать @SqlResultSetMapping
3. В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph
4. Если мы знаем примерное количество коллекций, которые будут использоваться в любом месте приложения - можно использовать @BatchSize https://docs.google.com/document/d/1QXEv9hnVRFHaPlPMF3CEIaxL8dQrWYx4MI5PLLj14Cc/ edit
`, img: `solution.png`},
    {q: `16. Entity Grpah.`, a: `FetchType.LAZY используется почти во всех случаях, чтобы получить хорошо работающее и масштабируемое приложение. Определение графа сущностей не зависит от запроса и определяет, какие атрибуты нужно извлечь из базы данных. Граф сущностей может использоваться в качестве выборки или графика загрузки. Если используется график выборки, только атрибуты, указанные в графе сущностей, будут обрабатываться как FetchType.EAGER. Все остальные атрибуты будут ленивыми. Если используется график загрузки, все атрибуты, которые не указаны в графе объектов, сохранят свой тип выборки по умолчанию.
    https://www.baeldung.com/jpa-entity-graph https://thoughts-on-java.org/jpa-21-entity-graph-part-1-named-entity/
    Для этого существует EntityGraph API, используется он так: с помощью аннотации @NamedEntityGraph для Entity, создаются именованные EntityGraph объекты, которые содержат список атрибутов у которых нужно поменять fetchType на EAGER, а потом данное имя указывается в hits запросов или метода find. В результате fetchType атрибутов Entity меняется, но только для этого запроса. Существует две стандартных property для указания EntityGraph в hit:
    1) javax.persistence.fetchgraph — все атрибуты перечисленные в EntityGraph меняют fetchType на EAGER, все остальные на LAZY
    2) javax.persistence.loadgraph — все атрибуты перечисленные в EntityGraph меняют fetchType на EAGER, все остальные сохраняют свой fetchType (то есть если у атрибута, не указанного в EntityGraph, fetchType был EAGER, то он и останется EAGER)С помощью NamedSubgraph можно также изменить fetchType вложенных объектов Entity. https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing
    Определение именованного графа сущностей выполняется аннотацией @NamedEntityGraph в сущности. Он определяет уникальное имя и список атрибутов ( attributeNodes ), которые должны быть загружены. https://thoughts-on-java.org/jpa-21-entity-graph-part-1-named-entity/ https://www.baeldung.com/jpa-entity-graph
    `, img: ``},
    {q: `17. Блокировки (оптимистические и пессимистические).`, a: `Блокировки, это механизм, позволяющий параллельную работу с одними и теми же данными в базе данных
    Оптимистичный подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им спокойно и свободно выполнять любые чтения и обновления данных. Но, при окончании транзакции, то есть записи данных
           
    в базу, производится проверка, изменились ли данные в ходе выполнения данной транзакции и если да, транзакция обрывается и выбрасывается исключение. Пессимистичный подход напротив, ориентирован на транзакции, которые постоянно или достаточно часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным превентивно, в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение)
    Оптимистичная блокировка делится на 2 типа : LockModeType.OPTIMISTIC - блокировка на чтение и LockModeType.OPTIMISTIC_FORCE_INCREMENT - блокировка на запись Пессимистичная блокировка на 2 типа - LockModeType.PESSIMISTIC_READ — данные блокируются в момент чтения, LockModeType.PESSIMISTIC_WRITE — данные блокируются в момент записи https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing`, img: ``},
    {q: `18. Кеширование (уровни кэширования, @Cacheable, @Cache,
        ehcache).
        `, a: `Кеширование является одним из способов оптимизации работы приложения, ключевой задачей которого является уменьшить количество прямых обращений к базе данных.
        Кэш первого уровня – это кэш Сессии (Session), который является обязательным. Через него проходят все запросы. Перед тем, как отправить объект в БД, сессия хранит объект за счёт своих ресурсов.
        В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление для того, чтобы сократить количество выполненных запросов. Если мы закроем сессию, то все объекты, находящиеся в кэше теряются, а далее – либо сохраняются, либо обновляются. Кэш первого уровня это и есть PersistenceContext.
        Кэш второго уровня является необязательным (опциональным) и изначально Hibernate будет искать необходимый объект в кэше первого уровня. В основном, кэширование второго уровня отвечает за кэширование объектов. Кэш второго уровня привязан к EntityManagerFactory.
        В Hibernate предусмотрен кэш для запросов и он интегрирован с кэшем второго уровня. Это требует двух дополнительных физических мест для хранения кэшированных запросов и временных меток для обновления таблицы БД. Этот вид кэширования эффективен только для часто используемых запросов с одинаковыми параметрами. https://proselyte.net/tutorials/hibernate-tutorial/caching/
        одновременного доступа к объектам в кэше в hibernate существует четыре:
        transactional — полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, как если бы только они с ним работали последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности.
        read-write — полноценный доступ к одной конкретной записи и разделение её состояния между транзакциями. Однако суммарное состояние нескольких объектов в разных транзакциях может отличаться.
        nonstrict-read-write — аналогичен read-write, но изменения объектов могут запаздывать и транзакции могут видеть старые версии объектов. Рекомендуется использовать в случаях, когда одновременное обновление объектов маловероятно и не может привести к проблемам.
           
        read-only — объекты кэшируются только для чтения и изменение удаляет их из кэша. Hibernate реализует область кэша для запросов resultset, который тесно взаимодействует с кэшем второго уровня Hibernate. Для подключения этой дополнительной функции требуется несколько дополнительных шагов в коде. Query Cache полезны только для часто выполняющихся запросов с повторяющимися параметрами. Для начала необходимо добавить эту запись в файле конфигурации Hibernate:
        Уже внутри кода приложения для запроса применяется метод setCacheable(true). https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing
        `, img: ``},
    {q: `19. HQL, JPQL.`, a: `JPQL основан на Hibernate Query Language (HQL), более раннем не стандартизированном языке запросов, включенном в библиотеку объектно-реляционного отображения Hibernate. Hibernate и HQL были созданы до появления спецификации JPA. JPQL является подмножеством языка запросов HQ. https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing`, img: ``},
    {q: `20. Criteria API.`, a: `Hibernate Criteria API является более объектно-ориентированным для запросов, которые получают результат из базы данных. Для операций update, delete или других DDL манипуляций использовать Criteria API нельзя. Критерии используются только для выборки из базы данных в более объектно-ориентированном стиле. Используется для динамических запросов
    Вот некоторые области применения Criteria API:
    Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д.
    Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок.
    Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection().
    Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions).
    Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder(). https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing
    `, img: ``},

    {q: `21. Hibernate proxy (lazy load).`, a: `Hibernate использует прокси объект для поддержки отложенной загрузки. Обычно при загрузке данных из таблицы Hibernate не загружает все отображенные (замаппинные) объекты. Как только вы ссылаетесь на дочерний объект или ищите объект с помощью геттера, если связанная сущность не находиться в кэше сессии, то прокси код перейдет к базе данных для загрузки связанной сущности. Для этого используется javassist, чтобы эффективно и динамически создавать реализации подклассов ваших entity объектов.
      
    https://docs.google.com/document/d/1F5t0pjTb5KpCiSEwSEdbCneBmOxnd4eNInXTPsbAnck/e dit?usp=sharing`, img: ``},
    {q: `22. Транзакции в Hibernate.`, a: `Hibernate построен поверх JDBC API и реализует модель транзакций JDBC. Если быть точным, Hibernate способен работать или с JDBC транзакциями или с JTA транзакциями — Java Transaction API.
    Транзакцию можно начать вызовом beginTransaction() объекта Session, либо запросить у Session связанный с ней объект Transaction и позвать у последнего метод begin(). С объектом Session всегда связан ровно один объект Transaction, доступ к которому может быть получен вызовом getTransaction().
    Методов для подтверждения или отката транзакции у объекта Session нет, необходимо всегда обращаться к объекту Transaction.
    В отличие от JDBC в Hibernate не поддерживаются Savepoints и транзакция может только быть подтверждена или откачена, без промежуточных вариантов.
    Операции над транзакциями
    У объекта Transaction есть ещё несколько методов, кроме commit() и rollback(), которые позволяют тонко управлять поведением транзакции. Метод isActive() позволяет проверить, есть ли в рамках объекта Transaction управляемая им транзакция. Очевидно, что такая транзакция существует в промежутке времени между вызовами begin() и commit()/rollback(). Метод setRollbackOnly() помечает транзакцию как откаченную в будущем. В отличие от rollback() этот метод не закрывает транзакцию и все последующие запросы к базе будут продолжать выполняться в рамках той же самой транзакции, но завершить эту транзакцию можно будет только откатом и вызовом rollback(). Вызов commit() на такой транзакции выбросит исключение. Проверить состояние транзакции можно вызовом getRollbackOnly(). https://easyjava.ru/data/hibernate/tranzakcii-i-blokirovki-v-hibernate/
    `, img: ``},
    {q: `1. Основные различия между JPA и JDBC (уровень абстракции)`, a: `Основное различие между JPA и JDBC - уровень абстракции:
    JDBC - это стандарт низкого уровня для взаимодействия с базами данных посредством SQL.
    JPA (Java Persistence API) это спецификация Java EE и Java SE, описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде. Сама Java не содержит реализации JPA, однако существует много реализаций данной спецификации от разных компаний (открытых и нет). Это не единственный способ сохранения java объектов в базы данных (ORM систем), но один из самых популярных в Java мире.
    https://stackoverflow.com/questions/11881548/jpa-or-jdbc-how-are-they-different https://habr.com/ru/post/265061/`, img: ``},
    {q: `2. Что такое хибер`, a: `Hibernate одна из самых популярных открытых реализаций спецификации JPA. JPA только описывает правила и API, а Hibernate реализует эти описания, впрочем у Hibernate (как и у многих других реализаций JPA) есть дополнительные возможности, не описанные в JPA (и не переносимые на другие реализации JPA).
    https://habr.com/ru/post/265061/
    Hibernate — библиотека для языка программирования Java, предназначенная для решения задач объектно-реляционного отображения (object-relational mapping — ORM). Она представляет собой свободное программное обеспечение с открытым исходным кодом (open source). Данная библиотека предоставляет легкий в использовании каркас (фреймворк) для отображения объектно-ориентированной модели данных в традиционные реляционные базы данных.`, img: ``},
    {q: `3. Будет ли JPQL запрос считаться корректным HQL запросом?`, a: `Hibernate Query Language(JPQL) основан на Hibernate Query Language (HQL).
    HQL ориентирован на запросы не к таблицам, а к классам. Любой JPQL запрос является одновременно и корректным HQL запросом. Обратное может быть не верно. https://easyjava.ru/data/hibernate/hibernate-query-language/
    `, img: ``},
    {q: `4. Когда вызываешь метод createQuery() какой интерфейс
    получаешь`, a: `При вызове createQuery() получаем интерфейс Query.
    Это объектно-ориентированное представление запроса Hibernate. Запрос экземпляра Query получается вызовом Session.createQuery(). https://docs.jboss.org/hibernate/orm/3.5/javadocs/org/hibernate/Query.html`, img: ``},
    {q: `5. Основные интерфейсы JPA (ОСНОВНЫЕ 2)`, a: `На следующем рисунке показана архитектура уровня класса JPA. Он показывает основные классы и интерфейсы JPA.
    1. EntityManagerFactory - это фабричный класс EntityManager. Он создает и управляет несколькими экземплярами EntityManager.
    2. EntityManager - это интерфейс; он управляет операциями сохранения на объектах. Это работает как фабрика для экземпляра Query .
    3. Entity - Сущности - это постоянные объекты, хранящиеся в виде записей в базе данных.
    4. EntityTransaction - имеет непосредственное отношение к EntityManager . Для каждого EntityManager операции поддерживаются классом EntityTransaction .
    5. Persistence - этот класс содержит статические методы для получения EntityManagerFactory экземпляра.
    6. Query - этот интерфейс реализуется каждым поставщиком JPA для получения реляционных объектов, соответствующих критериям.
    https://dzone.com/articles/introduction-to-jpa-architecture
    `, img: ``},
    {q: `6. Чем EntityManager отличается от Session`, a: `Реализация JPA EntityManager является оберткой (wrap) реализации Hibernate Session. Session расширяет интерфейс EntityManager. Если Вы выбираете путь JPA, то всегда имеете возможность быстро перейти, на другие реализации JPA - EclipseLink, OpenJPA, DataNucleus. При желании, можно работая с EntityManager дотянуться через unwrap до интерфейса Session и воспользоваться его функционалом. https://ru.stackoverflow.com/questions/965018/hibernate-%D1%80%D0%B0%D0%B7%D0%BD %D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-session-%D0%B8 -entitymanager
    https://javarush.ru/groups/posts/1502-voprosih-na-sobesedovanie-hibernate
    `, img: ``},
    {q: `7. Разница между EntityManagerFactory и SessionFactory`, a: `Hibernate SessionFactory расширяет JPA EntityManagerFactory.
    Таким образом, Hibernate SessionFactory это также JPA EntityManagerFactory.
    Оба SessionFactory и EntityManagerFactory содержат метаданные отображения сущностей и позволяют вам создавать Hibernate Session или EntityManager.
    Session против EntityManager
    Так же как SessionFactory и EntityManagerFactory, Hibernate Session расширяет JPA EntityManager. Итак, все методы, определенные в EntityManager, доступны в Hibernate Session.
    https://javarush.ru/groups/posts/1502-voprosih-na-sobesedovanie-hibernate https://stackoverflow.com/questions/5640778/hibernate-sessionfactory-vs-entitymanagerfactory
    `, img: ``},
    {q: `8. В каком случае я могу восстановить удаленную сущность
    `, a: `Refresh
    - Если статус Entity managed, то в результате операции Refresh будут восстановлены
    все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов
    `, img: ``},
    {q: `
    9. Что такое PersistenceContext (это и есть кэш 1-го уровня у
    EntityManager)`, a: `PersistenceContext (контекст постоянства) находится между клиентским кодом и БД. Это промежуточная область, где постоянные данные преобразуются в сущности, готовые для чтения и изменения клиентским кодом.
    Он отслеживает все загруженные данные, отслеживает изменения этих данных и несет ответственность за то, чтобы в конечном итоге синхронизировать любые изменения обратно в базу данных в конце транзакции.
    Hibernate, использует контекст постоянства для управления жизненным циклом объекта в приложении.
    Экземпляр EntityManager связан с PersistenceContext. PersistenceContext - это набор экземпляров объекта, в котором для любого постоянного идентификатора объекта существует уникальный экземпляр объекта. В PersistenceContext экземпляры сущности
    и их жизненный цикл управляются. EntityManager API используется для создания и удаления постоянных экземпляров сущностей, для поиска сущностей по их первичному ключу и для запросов к сущностям.
          
    PersistenceContext - это кэш первого уровня, в котором все объекты извлекаются из базы данных или сохраняются в базе данных. PersistenceContext отслеживает любые изменения, внесенные в управляемый объект. Если что-то меняется во время транзакции, то объект помечается как грязный. Когда транзакция завершается, эти изменения сбрасываются в постоянное хранилище.
    EntityManager это интерфейс, который позволяет нам взаимодействовать с контекстом постоянства. Всякий раз, когда мы используем EntityManager, мы фактически взаимодействуем с контекстом постоянства.
    PersistenceContext доступны в двух типах:
    ● PersistenceContext в области транзакций
    ● PersistenceContext расширенной области
    Транзакционный контекст персистентности.
    Контекст постоянства транзакции привязан к транзакции. Как только транзакция
    заканчивается, объекты, присутствующие в контексте постоянства, будут сброшены в постоянное хранилище.
    Когда мы выполняем какую-либо операцию внутри транзакции, EntityManager проверяет PersistenceContext. Если он существует, он будет использован. В противном случае это создаст PersistenceContext.
    Тип контекста персистентности по умолчанию - PersistenceContextType.TRANSACTION. Чтобы указать EntityManager использовать контекст постоянства транзакции, мы просто аннотируем его с помощью @PersistenceContext :
    @PersistenceContext
    private EntityManager entityManager; Расширенный персистентный контекст
    Расширенный контекст постоянства может охватывать несколько транзакций. Мы можем сохранить сущность без транзакции, но не можем сбросить ее без транзакции.
    Чтобы сказать EntityManager использовать контекст персистентности расширенной области, нам нужно применить атрибут type @PersistenceContext:
    @PersistenceContext(type = PersistenceContextType.EXTENDED)
    private EntityManager entityManager; https://www.baeldung.com/jpa-hibernate-persistence-context
    `, img: ``},
    {q: `10. Как отсоединить сущность от контекста, какими методами`, a: `Когда сущность только создана и записана в базу данных или когда наоборот, прочитана из базы данных, она входит в PersistenceContext и обладает неким экземпляром Session, который ей управляет. Однако из этого состояния она может внезапно перейти в состояние «отделенная» (detached). В этом состоянии сущность не связана со своим контекстом (отделена от него) и нет экземпляра Session, который бы ей управлял.
    Перейти в это состояние сущность может по следующим причинам:
    ● Явный перевод из persisted в detached вызовом метода evict() у Session.
    ● Сброс контекста методом clear() у Session.
    ● Явное закрытие сессии методом close().
    ● Неявное закрытие сессии связанное с удалением объекта Session.
     
    Над detached объектом нельзя выполнять операции, которые требуют наличия PersistenceContext.
    detached сущность можно вернуть в состояние persisted вызовами merge(), lock() или update(), но не saveOrUpdate(). https://easyjava.ru/data/hibernate/upravlenie-sushhnostyami-v-hibernate/`, img: ``},
    {q: `11. Как можно конфигурировать хибернейт - какими способами
    (SessionFactory & EntityManagerFactory)`, a: `Существует четыре способа конфигурации работы с Hibernate : — используя аннотации;
    — hibernate.cfg.xml;
    — hibernate.properties;
    — persistence.xml.
    Самый частый способ конфигурации: через аннотации и файл persistence.xml, что касается файлов hibernate.properties и hibernate.cfg.xml, то hibernate.cfg.xml главнее (если в приложение есть оба файла, то принимаются настройки из файла hibernate.cfg.xml). Конфигурация аннотациями, хоть и удобна, но не всегда возможна, например, если для разных баз данных или для разных ситуаций вы хотите иметь разные конфигурацию сущностей, то следует использовать xml файлы конфигураций.
    По мимо этого хибернейт можно сконфигурировать с использованием SessionFactory или EntityManagerFactory.
    При использовании JPA или Hibernate у вас есть два варианта:
    1. Вы можете загрузиться с помощью встроенного механизма Hibernate и создать SessionFactory.
    2. Или вы можете создать JPA EntityManagerFactory
    Начальная загрузка через JPA должна быть предпочтительной. Кроме того, если вы использовали JPA, и вы вводили EntityManagerFactory через @PersistenceUnit аннотации:
    @PersistenceUnit
    private EntityManagerFactory entityManagerFactory;
    Вы можете легко получить доступ к базовому SessionFactory используя unwrap метод:
    SessionFactory sessionFactory = entityManagerFactory.unwrap(SessionFactory.class); То же самое можно сделать с JPA EntityManager. Если вы вводите EntityManager через @PersistenceContext аннотацию:
    @PersistenceContext
    private EntityManager entityManager;
    Вы можете легко получить доступ к базовому, Session используя unwrap метод:
    Session session = entityManager.unwrap(Session.class); Вывод
    Таким образом, вам следует загружать через JPA, использовать EntityManagerFactory и EntityManager и развертывать их только в связанных с ними интерфейсах Hibernate, когда вы хотите получить доступ к некоторым специфичным для Hibernate методам, которые недоступны в JPA, например, к извлечению объекта через его естественный идентификатор.
    https://javarush.ru/groups/posts/1502-voprosih-na-sobesedovanie-hibernate https://stackoverflow.com/questions/5640778/hibernate-sessionfactory-vs-entitymanagerfactory
    `, img: ``},
    {q: `12. Основные аннотации хибера`, a: `Hibernate поддерживает как аннотации из JPA, так и свои собственные, которые находятся в пакете org.hibernate.annotations. Наиболее важные аннотации JPA и Hibernate:
    1. @Entity: используется для указания класса как entity bean.
    2. @Table: используется для определения имени таблицы из БД, которая будет
    отображаться на entity bean.
    3. @Access: определяет тип доступа, поле или свойство. Поле — является значением
    по умолчанию и если нужно, чтобы hibernate использовал методы getter/setter, то их
    необходимо задать для нужного свойства.
    4. @Id: определяет primary key в entity bean.
    5. @EmbeddedId: используется для определения составного ключа в бине.
    6. @Column: определяет имя колонки из таблицы в базе данных.
    7. @GeneratedValue: задает стратегию создания основных ключей. Используется в
    сочетании с javax.persistence.GenerationType enum.
    8. @OneToOne: задает связь один-к-одному между двумя сущностными бинами.
    Соответственно есть другие аннотации @OneToMany, @ManyToOne и
    @ManyToMany.
    9. @Cascade: определяет каскадную связь между двумя entity бинами. Используется в
    связке с org.hibernate.annotations.CascadeType.
    10. @PrimaryKeyJoinColumn: определяет внешний ключ для свойства. Используется
    вместе с org.hibernate.annotations.GenericGenerator и org.hibernate.annotations.Parameter.`, img: ``},
    {q: `13. @Id`, a: `С помощью @Id мы указываем первичный ключ (Primary Key) данного класса.
    Типы переменных для @Id: примитивные и примитивные типы-оболочки, String, Date, BigDecimal, BigInteger.
    https://proselyte.net/tutorials/hibernate-tutorial/annotations/ https://www.baeldung.com/hibernate-identifiers https://docs.oracle.com/javaee/7/api/javax/persistence/Id.html
    `, img: ``},
    {q: `14. Стратегии генерации @Id - знать все!!!!`, a: `GenerationType.AUTO является типом генерации по умолчанию. Выбирает стратегию генерации на основе конкретного диалекта базы данных. Для большинства популярных баз данных он выбирает GenerationType.SEQUENCE.
    GenerationType.IDENTITY является самым простым в использовании, но не самый лучший с точки зрения производительности. Он опирается на автоматически увеличивающийся столбец базы данных и позволяет базе данных генерировать новое значение при каждой операции вставки. Hibernate требует значения первичного ключа для каждого управляемого объекта и поэтому должен немедленно выполнить оператор вставки. Это предотвращает использование различных методов оптимизации, таких как пакетная обработка JDBC. (Идентити делает инсерт до персиста).
    GenerationType.SEQUENCE использует последовательность базы данных для генерации уникальных значений.
    Для получения следующего значения из последовательности базы данных требуются дополнительные операторы select. Но это не влияет на производительность для большинства приложений. (Секвенс делает селект, чтобы сгенерить id).
    GenerationType.TABLE используется редко. Он моделирует последовательность, сохраняя и обновляя ее текущее значение в таблице базы данных, что требует
       
    использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок. Это замедляет работу вашего приложения https://thoughts-on-java.org/jpa-generate-primary-keys/
    https://habr.com/ru/post/416851/`, img: ``},
    {q: `15. Что означает стратегия @GeneratedValue.IDENTITY`, a: `GenerationType.IDENTITY является самым простым в использовании, но не самый лучший с точки зрения производительности. Он опирается на автоматически увеличивающийся столбец базы данных и позволяет базе данных генерировать новое значение id при каждой операции вставки. Hibernate требует значения первичного ключа для каждого управляемого объекта и поэтому должен немедленно выполнить оператор вставки. Это предотвращает использование различных методов оптимизации, таких как пакетная обработка JDBC. (Идентити делает инсерт до персиста). https://thoughts-on-java.org/jpa-generate-primary-keys/
    `, img: ``},
    {q: `16. На какой стороне инкрементится id- на стороне базы или
    хибернейта`, a: `GenerationType.IDENTITY - id инкрементится на стороне базы GenerationType.SEQUENCE - id инкрементится на стороне хибера, использует дополнительные селекты, чтобы запросить id https://thoughts-on-java.org/jpa-generate-primary-keys/
    `, img: ``},

    {q: `17. @Column`, a: `@Column нужна чтобы указать детали столбца в таблице.
    @Column аннотации имеет много атрибутов, такие как name, length, nullable и unique. Элемент name указывает имя столбца в таблице. Элемент length указывает его длину. атрибут nullable определяет, является ли элемент обнуляемым, и unique атрибут определяет, является ли уникальным столбец.
    Если мы не укажем эту аннотацию, имя поля будет считаться именем столбца в таблице. https://www.baeldung.com/jpa-entities https://proselyte.net/tutorials/hibernate-tutorial/annotations/ https://docs.oracle.com/javaee/7/api/javax/persistence/Column.html`, img: ``},
    {q: `18. @Acess`, a: `@Access: определяет тип доступа, поле или свойство. Поле — является значением по умолчанию и если нужно, чтобы hibernate использовал методы getter/setter, то их необходимо задать для нужного свойства. https://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html https://habr.com/ru/post/265061/ https://thoughts-on-java.org/access-strategies-in-jpa-and-hibernate/
    `, img: ``},
    {q: `19. Что означает двусторонняя связь. Как это отобразится в коде`, a: `У нас есть таблица для каждой корзины и еще одна таблица для каждого товара. В одной корзине может быть много товаров, поэтому здесь у нас есть отображение «один ко многим» .
          
    То, как это работает на уровне базы данных, заключается в том, что у нас есть cart_id в качестве первичного ключа в таблице корзины, а также cart_id в качестве внешнего ключа в элементах .
    И способ, которым мы делаем это в коде, с @OneToMany .
    Давайте сопоставим класс Cart объекту Items таким образом, чтобы он отражал отношения в базе данных:
    @Entity @Table(name="CART") public class Cart {
    //...
    @OneToMany(mappedBy="cart") private Set<Items> items; // getters and setters
    }
    @Entity @Table(name="ITEMS") public class Items {
    //...
    @ManyToOne
    @JoinColumn(name="cart_id", nullable=false) private Cart cart;
    public Items() {}
    // getters and setters
    }
    Мы также можем добавить ссылку на корзину в пунктах, используя @ManyToOne, что делает это двунаправленным отношением. Двунаправленный означает, что мы можем получить доступ к предметам из корзины, а также к корзине из предметов.
    Свойство mappedBy - это то, что мы используем, чтобы сообщить Hibernate, какую переменную мы используем для представления родительского класса в нашем дочернем классе.
    @OneToMany используется для определения свойства в классе Items, которое будет использоваться для сопоставления переменной mappedBy. Вот почему у нас есть свойство с именем «cart» в классе Items:
    @ManyToOne связана с переменной класса Cart. Аннотация @JoinColumn ссылается на сопоставленный столбец.
    https://www.baeldung.com/hibernate-one-to-many
    `, img: ``},
    {q: `20. Что произойдет если не поставить mappedBy на @OneToOne
    @OneToMany - почему выгодно ставить mapped by на этих типах
    связей`, a: `mappedBy делает связь двунаправленной. Без mappedBy связь будет однонаправленной. После того, как мы определили сторону-владельца отношений, Hibernate уже располагает всей информацией, необходимой для отображения этих отношений в нашей базе данных. Чтобы сделать эту ассоциацию двунаправленной, все, что нам нужно сделать, это определить сторону ссылки. Обратная или ссылочная сторона просто отображается на сторону-владельца.
 
    Мы можем легко использовать mappedBy атрибут @OneToMany аннотацию , чтобы сделать это. Итак, давайте определим нашу сущность Employee :
    @Entity @Table(name="ITEMS") public class Items {
    //...
    @ManyToOne
    @JoinColumn(name="cart_id", nullable=false) private Cart cart;
    public Items() {}
    // getters and setters
    }
    Здесь значение mappedBy является именем атрибута сопоставления ассоциации на стороне владельца. Благодаря этому мы установили двустороннюю связь между нашими сотрудниками и сотрудниками электронной почты. https://www.baeldung.com/jpa-joincolumn-vs-mappedby
    `, img: ``},
    {q: `21. @JoinColumn`, a: `Указывает столбец для присоединения к связной сущности или коллекции элементов. Если сама аннотация @JoinColumn имеет значение по умолчанию, то предполагается наличие одного столбца соединения и применяются значения по умолчанию. https://docs.oracle.com/javaee/7/api/javax/persistence/JoinColumn.html
    @JoinColumn - в связях вида One2Many/Many2One сторона, находящаяся в собственности обычно называется стороной “многих”. Обычно, это сторона, которая держит внешний ключ. Эта аннотация, фактически, описывает физический (как в бд) маппинг на стороне “многих”. В атрибут name этой аннотации дается название колонки, которая будет присоединена к таблице “многих” и которая будет заполняться значениями первичных ключей из таблицы-собственника. Таким образом - мы даём название для внешнего ключа. По факту - использование этой аннотации опционально, т.к. хибернейт, проанализировав сущность - поймет сам, что в таблице для этого класса нужно создать колонку, обозначающую внешний ключ, и даст ей соответствующее название “{name}_id”. https://docs.google.com/document/d/1QXEv9hnVRFHaPlPMF3CEIaxL8dQrWYx4MI5PLLj14Cc/ edit
    `, img: ``},
    {q: `22. @JoinTable`, a: `Определяет сопоставление ассоциации. Он применяется к владельцу ассоциации. @JoinTable обычно используется при отображении связей «многие ко многим» и однонаправленных связей «один ко многим». Он также может использоваться для сопоставления двунаправленных ассоциаций «многие к одному» или «один ко многим», однонаправленных связей «многие к одному» и связей «один к одному» (как двунаправленных, так и однонаправленных).
    Когда @JoinTable используется при отображении отношения с встраиваемым классом на стороне-владельце отношения, содержащая сущность, а не встраиваемый класс считается владельцем отношения.
    Если @JoinTable аннотация отсутствует, применяются значения по умолчанию для элементов аннотации.
    https://docs.oracle.com/javaee/7/api/javax/persistence/JoinTable.html`, img: ``},
    {q: `23. Университеты и Студенты - @MаnyToMany - можно ли обойтись
    просто этой аннотацией без @JoinTable и @JoinColumn`, a: `Вроде как нет, т.к. нам нужна третья таблица для связи ManyToMany (связать первичный и внешний ключ). https://stackoverflow.com/questions/7979382/how-to-create-join-table-with-jpa-annotations`, img: ``},
    {q: `24. При аннотации @ManyToMany - ОБА ВЛАДЕЛЬЦЫ СВЯЗИ`, a: `Настройка каскадов этой связи немного сложнее т.к. связь по умолчанию является двунаправленной, и, более того, в этой связи зачастую невозможно выделить собственность и собственника, т.к. границы между ними сильно размыт. Получается картина, когда обе стороны могут передавать каскадные изменения друг на друга.
    Важно не использовать на связи @ManyToMany CascadeType.All, т.к. последний включает в себя каскад на Remove, а этот каскад заставляет удалять хибернейт данные не только из смежной таблицы, но и дальше, из таблицы сущности, которая привязана к данной. А за этим, если к этой сущности были привязаны ещё несколько других - произойдет и их удаление из базы https://docs.google.com/document/d/1QXEv9hnVRFHaPlPMF3CEIaxL8dQrWYx4MI5PLLj14Cc/ edit
    `, img: ``},
    {q: `25. Что ты знаешь про стратегии загрузки`, a: `В JPA описаны два типа fetch стратегии:
    1) LAZY — данные поля будут загружены только во время первого доступа к этому полю 2) EAGER — данные поля будут загружены немедленно
    https://habr.com/ru/post/265061/`, img: ``},
    {q: `26. Стратегии загрузки по умолчанию для всех видов связей, а
    также для аннотации @Basic и @Collection`, a: `EAGER для @Basic и ToOne
    LAZY для @Collection и ToMany https://docs.jboss.org/hibernate/orm/5.1/userguide/html_single/chapters/domain/collections.html https://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/collections.html
    `, img: ``},
    {q: `27. Что такое встраиваемый класс (@Embedded)`, a: `Встраиваемый (Embeddable) класс это класс который не используется сам по себе, только как часть одного или нескольких Entity классов. Entity класс могут содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity класса и не может быть использован для передачи данных между объектами Entity классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity, можно считать что JPA просто встраивает в Entity вместо объекта такого класса те атрибуты, которые он содержит.
    1. Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией Entity
         
    2. Embeddable класс должен быть помечен аннотацией @Embeddable или описан в XML файле конфигурации JPA,
    https://www.baeldung.com/jpa-embedded-embeddable
    https://habr.com/ru/post/265061/`, img: ``},
   
    {q: `28. Как создать составной первичный ключ - где это указывать, как
    это должно правильно работать`, a: `Допустимые типы атрибутов, входящих в первичный ключ: 1. примитивные типы и их обертки Java
    2. строки
    3. BigDecimal и BigInteger
    4. java.util.Date и java.sql.Date
    В случае автогенерируемого первичного ключа (generated primary keys) допустимы
    1. только числовые типы
    В случае использования других типов данных в первичном ключе, он может работать только для некоторых баз данных, т.е. становится непереносимым (not portable) https://habr.com/ru/post/265061/
    @EmbeddedId указывает на поле составного первичного ключа, а @Embeddable объявляет класс составным ключом.
    @Embeddable
    public class BillingAddress implements Serializable {...} @Entity
    @Table(name = "PURCHASE_ORDERS") @IdClass(BillingAddress.class)
    public class PurchaseOrder {...}
    Обратите внимание, что есть некоторые ключевые требования, которым должен соответствовать класс составного ключа:
    Мы должны пометить его с помощью @Embeddable.
    Он должен реализовать java.io.Serializable
    Мы должны обеспечить реализацию hashCode() и Equals() методы
    Ни одно из полей не может быть сущностью https://www.baeldung.com/jpa-many-to-many https://www.ibm.com/developerworks/ru/library/os-hibernatejpa/index.html
    `, img: ``},
    {q: `29. Для чего еще нужен @Embedded - второй случай, если опустить
    составной ключ`, a: `В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity, можно считать что JPA просто встраивает в Entity вместо объекта такого класса те атрибуты, которые он содержит.
    https://habr.com/ru/post/265061/`, img: ``},
    {q: `30. Как работает первый уровень кэша - когда он есть - когда нет - к
    чему он привязан (к какому объекту)`, a: `Кэширование - это средство, предоставляемое средами ORM, которое помогает пользователям быстро запустить веб-приложение, а сама структура помогает сократить
      
    количество запросов к базе данных за одну транзакцию. Hibernate достигает второй цели, внедряя кэш первого уровня.
   Кэш первого уровня в hibernate включен по умолчанию, и вам не нужно ничего делать, чтобы эта функция работала. На самом деле, вы не можете отключить его даже принудительно.
   Кэш первого уровня легко понять, если мы понимаем тот факт, что он связан с объектом Session. Как мы знаем, объект сеанса создается по требованию из фабрики сеансов и теряется при закрытии сеанса. Аналогично, кэш первого уровня, связанный с объектом сеанса, доступен только до тех пор, пока объект сеанса не станет активным. Он доступен только для объекта сеанса и не доступен для любого другого объекта сеанса в любой другой части приложения.
   Важные факты
   1. Кэш первого уровня связан с объектом Session, а другие объекты сеанса в приложении его не видят.
   2. Область действия объектов кэша имеет сессию. Как только сессия закрыта, кэшированные объекты исчезают навсегда.
   3. Кэш первого уровня включен по умолчанию, и вы не можете его отключить.
   4. Когда мы запрашиваем объект в первый раз, он извлекается из базы данных
   и сохраняется в кэше первого уровня, связанном с сессией хибернейта.
   5. Если мы снова запросим тот же объект с тем же объектом сеанса, он будет
   загружен из кэша, и никакой SQL-запрос не будет выполнен.
   6. Загруженный объект можно удалить из сеанса с помощью метода evict(). Следующая загрузка этого объекта снова вызовет базу данных, если она
   была удалена с помощью метода evict().
   7. Весь кэш сеанса можно удалить с помощью метода clear(). Это удалит все
   сущности, хранящиеся в кэше.
   Несколько фактов про кэш первого уровня:
   1. Кэш первого уровня не является потокобезопасным.
   2. Кэш первого уровня привязан к сессии и уничтожается следом за уничтожением
   сессии.
   Из этого следует один важный вывод: кэш первого уровня не является средством оптимизации большого количества повторяющихся запросов на выборку со стороны клиента, т.к. каждый запрос будет обрабатываться в отдельной транзакции, на которую будет выделен новый объект entityManager, который связан напрямую с новой сессией. Соответственно, на 20 одинаковых запросов пользователя будет создано 20 entityManager и 20 сессий. Будет выделено 20 транзакций, даже если запросы обрабатываются и поступают одновременно.
   Кэш первого уровня нужен:
   1. Для сохранения целостности данных
   2. Оптимизации запросов на изменение/удаление
   3. Оптимизация запросов на выборку в рамках одной транзакции
   В пределах жизненного цикла одной сессии и в рамках одной транзакции мы можем изменить внутреннее состояние сущности неограниченное количество раз, каждое изменение будет вноситься в кэш первого уровня. Но в базу запрос отправится только тогда, когда будет сделан комит транзакции. В базу отправятся те данные, которые содержит сущность на момент последнего изменения. До тех пор, пока транзакция не
   
   будет закончена - все изменения будут храниться в кэше. Даже если мы вызовем 20 раз метод setField() у любой сущности - в базу в итоге отправится только один запрос.
   Если же мы вынуждены читать в рамках одной транзакции несколько раз одни и те же данные, то, единожды загрузив данные запросом из базы мы будем в дальнейшем работать с данными внутри кэша, не повторяя дополнительных запросов. Например, если достать List<User> и затем достать конкретного юзера с id=2, то запрос в базу не будет произведен, т.к. список всех пользователей уже лежит в кэше. Так же, если мы, уже после того как достали пользователя с id=2 изменили 10 раз его имя, а затем снова выберем список всех пользователей - мы и в этом случае не получим дополнительных запросов. В описанном выше случае будет произведено только два запроса: на выборку списка всех пользователей в самом начала и один запрос на изменение состояния пользователя уже в конце транзакции. https://howtodoinjava.com/hibernate/understanding-hibernate-first-level-cache-with-example/
   `, img: ``},
    {q: `31. К какому объекту привязан кэш второго уровня (к
        EntityManagerFactory)`, a: `Кэш второго уровня создается в области фабрики EntityManagerFactory и доступен для использования во всех EntityManager, которые создаются с использованием этой конкретной фабрики.
        Это также означает, что после закрытия фабрики весь кэш, связанный с ним, умирает, а менеджер кэша также закрывается.
        Кроме того, это также означает, что если у вас есть два экземпляра фабрики, в вашем приложении будет два менеджера кэша, и при доступе к кэшу, хранящемуся в физическом хранилище, вы можете получить непредсказуемые результаты, такие как пропадание кеша.
        1. Всякий раз, когда сессия пытается загрузить объект, самое первое место, где он ищет кэшированную копию объекта в кэше первого уровня.
        2. Если кэшированная копия объекта присутствует в кэше первого уровня, она возвращается как результат метода загрузки.
        3. Если в кэше первого уровня нет кэшированной сущности, то для кэшированной сущности ищется кэш второго уровня.
        4. Если кэш второго уровня имеет кэшированный объект, он возвращается как результат метода load(). Но перед возвратом объекта он также сохраняется в кэше первого уровня, так что при следующем вызове метода загрузки объект будет возвращен из самого кэша первого уровня, и больше не потребуется обращаться в кэш второго уровня.
        5. Если объект не найден в кэше первого уровня и кэше второго уровня, то выполняется запрос к базе данных, и объект сохраняется на обоих уровнях кэша перед возвратом в качестве ответа метода load().
        6. Кэш второго уровня проверяет себя для измененных объектов.
        7. Если какой-либо пользователь или процесс вносят изменения
        непосредственно в базу данных, то само по себе кэширование второго уровня не может обновляться до тех пор, пока не истечет время «timeToLiveSeconds» для этой области кэша. В этом случае хорошей идеей будет сделать недействительным весь кеш и позволить hibernate снова построить кэш.
        https://howtodoinjava.com/hibernate/how-hibernate-second-level-cache-works/`, img: ``},
    {q: `32. Как настроить кэш второго уровня.`, a: `Со следующими двумя свойствами мы сообщаем Hibernate, что кэширование L2 включено, и даем ему имя класса фабрики региона:
    hibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCac heRegionFactory
    Чтобы сделать объект пригодным для кэширования второго уровня, мы помечаем его аннотацией @Cache или @Cacheable, специфичной для Hibernate, и указываем стратегию параллельного использования кэша:
    1) ALL — все Entity могут кэшироваться в кэше второго уровня
    2) NONE — кеширование отключено для всех Entity
    3) ENABLE_SELECTIVE — кэширование работает только для тех Entity, у которых установлена аннотация Cacheable(true), для всех остальных кэширование отключено
    4) DISABLE_SELECTIVE — кэширование работает для всех Entity, за исключением тех у которых установлена аннотация Cacheable(false)
    5) UNSPECIFIED — кеширование не определенно, каждый провайдер JPA использует свою значение по умолчанию для кэширования https://www.baeldung.com/hibernate-second-level-cache
    `, img: ``},
    {q: `33. Какой кэш еще есть. Кэш запросов - как настроить. Желательно
    понимать как объекты хранятся в кэше второго уровня и в кэше
    запросов.`, a: `Hibernate также поддерживает QueryCache, который может хранить результаты запроса. Вам необходимо активировать его в файле persistence.xml, установив для параметра
    hibernate.cache.use_query_cache=true и определив
    hibernate.cache.region.factory_class
    Кроме того, вам также необходимо активировать кэширование для конкретного запроса, для которого вы хотите кэшировать результаты, вызывая
    setCacheable(true) https://thoughts-on-java.org/hibernate-tips-use-querycache-avoid-additional-queries/
    `, img: ``},
    {q: `34 Как контролировать объекты второго уровня кэша - как удалить
    как посмотреть.`, a: `Сохранение или обновление элемента: save()
    update() saveOrUpdate()
    Получение предмета: load()
    get() list() iterate() scroll()
    Состояние объекта синхронизируется с базой данных при вызове метода flush(). Чтобы избежать этой синхронизации, вы можете удалить объект и все коллекции из кэша первого
      
    уровня с помощью evict() метода. Чтобы удалить все элементы из кэша сеанса, используйте метод Session.clear():
    ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
    while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0); doSomethingWithACat(cat); sess.evict(cat);
    }
    Определение того, принадлежит ли элемент кешу сеанса. Сеанс предоставляет contains() метод для определения того, принадлежит ли экземпляр кешу сеанса. https://docs.jboss.org/hibernate/orm/4.3/devguide/en-US/html/ch06.html
    `, img: ``},
    {q: `35. @Basic`, a: `@Basic — указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле null или нет.
    https://habr.com/ru/post/265061/
    Самый простой тип сопоставления со столбцом базы данных. Базовая аннотация может быть применена к постоянному свойству или переменной экземпляра любого из следующих типов: примитивные типы Java, оболочки примитивных типов, String, BigInteger, BigDecimal, Date, Calendar, Time, Timestamp, byte[], Byte[], char[], Character[], enums, и любой другой тип, который реализует java.io.Serializable.
    Использование базовой аннотации является необязательным для постоянных полей и свойств этих типов. Если базовая аннотация не указана для такого поля или свойства, то будут применяться значения по умолчанию базовой аннотации. https://docs.oracle.com/javaee/7/api/javax/persistence/Basic.html
    `, img: ``},
    {q: `36. @ElementCollection`, a: `Определяет коллекцию экземпляров базового типа или встраиваемого класса. Должен быть указан, если коллекция должна отображаться с помощью таблицы коллекции. https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/ElementCollection.html`, img: ``},
    {q: `37. @OrderBy`, a: `Определяет порядок элементов коллекции, оцениваемой ассоциацией или коллекцией элементов, в тот момент, когда ассоциация или коллекция извлекаются. https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/OrderBy.html
    @OrderBy могут быть применены к элементу коллекции. Когда OrderBy применяется к коллекции элементов базового типа, порядок будет по значению базовых объектов, а имя свойства или поля не используется. При указании порядка для коллекции элементов встраиваемого типа необходимо использовать точечную нотацию для указания атрибута или атрибутов, которые определяют порядок. https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/OrderBy.html`, img: ``},
    {q: `38. @OrderColumn - как работает, где ставится`, a: `Указывает столбец, который используется для поддержания постоянного порядка списка. @OrderColumn указывается в отношении OneToMany или ManyToMany или в коллекции элементов. @OrderColumn указывается на стороне отношения, ссылающейся на коллекцию, которая должна быть упорядочена. https://docs.jboss.org/hibernate/jpa/2.1/api/javax/persistence/OrderColumn.html`, img: ``},
    {q: `39. Различия между @OrderBy и @OrderColumn - пример с базой
    данных`, a: `@OrderBy в запросе отсортирует, а в кэше вернет неотсортированный порядок. @OrderedColumn сортирует данные с учетом данных в колонке, и в кеше и в запросе. Указанный порядок @OrderBy применяется только во время выполнения при получении результата запроса.
    @OrderColumn приводит к постоянному упорядочению соответствующих данных.
    https://www.logicbig.com/tutorials/java-ee-tutorial/jpa/order-by-annotation.html`, img: ``},
    {q: `40. OrphanRemoval`, a: `@OrphanRemoval - управляет поведением осиротевшими сущностями.
    OrphanRemoval: если мы вызовем setOrders(null), Order энтити будет удалена из БД автоматически.
    Если каскад ремув, то setOrders(null), Order НЕ БУДЕТ УДАЛЕНА из БД автоматически. Удаление сирот в отношениях
    Когда целевой объект в отношении «один-к-одному» или «один-ко-многим» удаляется из отношения, часто желательно каскадно удалить операцию для целевого объекта. Такие целевые объекты считаются «сиротами», а атрибут orphanRemoval может использоваться для указания того, что потерянные объекты должны быть удалены. Например, если в заказе много позиций, и одна из них удалена из заказа, удаленная позиция считается сиротой. Если для orphanRemoval установлено значение true, объект позиции будет удален при удалении позиции из заказа.
    https://docs.oracle.com/cd/E19798-01/821-1841/giqxy/`, img: ``},
    {q: `41. Почему есть Cascade Removal и orphanRemoval - есть еще один
    случай - когда есть разница? А при удалении разницы нет - в каком
    случае есть?`, a: `CascadeType определяет каскадные операции, которые применяются в элементе каскада аннотаций отношений.
    Пример : позиция является частью заказа; если заказ удален, позиция также должна быть удалена. Это называется каскадным отношением удаления.
    orphanRemoval - когда целевой объект в отношении один-к-одному или один-ко-многим удаляется из отношения.
    Пример: если в заказе много позиций, и одна из них удалена из заказа, удаленная позиция считается сиротой. Если для orphanRemoval установлено значение true, объект позиции будет удален при удалении позиции из заказа.
    Когда использовать:
    Каскадное удаление удаляет все дочерние элементы при удалении родителя.
       
    Таким образом, если вы удалите пользовательскую сущность, JPA удалит также все его фотографии. https://agritsik.wordpress.com/2015/08/06/orphan-removal-vs-cascade-delete-or-how-to-delete-r elated-entities/
    `, img: ``},
    {q: `42. Метод unWrap()
    `, a: `JPA обеспечивает легкий доступ к API базовых реализаций. EntityManager и EntityManagerFactory обеспечивают разворачивают метод, который возвращает соответствующие классы реализации JPA. В случае Hibernate это Session и SessionFactory.
    Session session = em.unwrap(Session.class); SessionFactory sessionFactory = em.getEntityManagerFactory().unwrap(SessionFactory.class);
    В первой строке я получаю текущий сеанс Hibernate от EntityManager . Поэтому я называю UnWrap метод на EntityManager и обеспечить сеанс класса в качестве параметра.
    Вторая строка выглядит очень похоже. Я получаю EntityManagerFactory для текущего EntityManager и вызываю метод unwrap специфичный для Hibernate класс SessionFactory. Эти классы предоставляют вам полный доступ к проприетарным функциям Hibernate, таким как поддержка Streams и Optional. https://thoughts-on-java.org/hibernate-tips-access-hibernate-apis-jpa/
    `, img: ``},
    {q: `43. Каким методом очищается кэш 1-го уровня`, a: `Это делается с помощью двух методов:
    evict()
    clear()
    Здесь evict() используется для удаления конкретного объекта из кэша, связанного с сеансом, а метод clear() используется для удаления всех кэшированных объектов, связанных с сеансом. https://howtodoinjava.com/hibernate/understanding-hibernate-first-level-cache-with-example/`, img: ``},

];
export default hyberCards;



//  {q: ``, a: ``, img: ``}